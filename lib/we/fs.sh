#!/usr/bin/env bash
set -euo pipefail

upsert_makefile(){
  local out=${1:-Makefile}
  local tmp="/tmp/we_make_block.$$"
  
  # Overwrite existing Makefile safely; do not delete .we (it holds logs)
  if [ -f "$out" ]; then
    echo "Rewriting $out"
  fi
  
  # Determine path to Python CLI (prefer local for repo dev, fallback to installed path)
  # This allows generated Makefiles to work both inside this repo and in external projects.
  local uuctl_fallback="$HOME/.local/share/we/tools/uuctl.py"
  # We intentionally keep the primary call as "tools/uuctl.py" for repository tests,
  # and use the absolute fallback if that file is not present in the project.
  
  # Generate the Makefile with placeholders (we will substitute values afterwards)
  cat > "$tmp" <<'EOF'
# Quiet by default. Use: make VERBOSE=1 <target>
ifeq ($(VERBOSE),1)
  # Verbose: default GNU make behavior
else
  .SILENT:
  MAKEFLAGS += --no-print-directory
  # MAKEFLAGS += --output-sync=target
endif

# BEGIN: we-managed-block
# (generated by we)
SERVICE := __WE_SERVICE__
PROJECT := __WE_PROJECT__
ENTRY := __WE_ENTRY__
WE_SERVICES := __WE_SERVICE__

.PHONY: up.$(SERVICE) down.$(SERVICE) ps.$(SERVICE) logs.$(SERVICE) follow.$(SERVICE) restart.$(SERVICE) doctor.$(SERVICE) unit.$(SERVICE) journal.$(SERVICE) watch.$(SERVICE) launch.$(SERVICE) run.$(SERVICE) kill.$(SERVICE) up down ps logs follow restart doctor unit journal watch launch run kill

# Unit identity
UNIT_SUFFIX := $(shell python -c "import hashlib,os; import sys; print(hashlib.sha1(os.path.abspath('.' + os.sep).encode()).hexdigest()[:8])")
UNIT := we-$(SERVICE)-$(UNIT_SUFFIX)

# Locations
RUNDIR := .we/$(SERVICE)
RUNLOG := $(RUNDIR)/run.log
LOGDIR := $(RUNDIR)/logs
KEEP_N ?= 10
SECURE ?= 0
RELOAD ?= 1
TAIL ?= 100

# watchexec / commands
WEX := $(shell command -v watchexec >/dev/null 2>&1 && echo "watchexec --restart --watch . --exts py --ignore .we --ignore .uu --ignore .git --ignore .venv --" || echo "")
CMD_RELOAD := cd "$(PROJECT)" && $(WEX) uv run --project "$(PROJECT)" -- $(ENTRY)
CMD_PLAIN := cd "$(PROJECT)" && uv run --project "$(PROJECT)" -- $(ENTRY)

# Python CLI path fallback (used only if tools/uuctl.py is absent in project)
UUCTL_FALLBACK := $(HOME)/.local/share/we/tools/uuctl.py

# ensure directories and RUNLOG symlink, then start under systemd-run
up.$(SERVICE):
	@cd "$(PROJECT)" && SERVICE="$(SERVICE)" PROJECT="$(PROJECT)" ENTRY="$(ENTRY)" RELOAD="$(RELOAD)" KEEP_N="$(KEEP_N)" SECURE="$(SECURE)" \
	  (uv run -- python tools/uuctl.py up || uv run -- python "$(UUCTL_FALLBACK)" up)

# stop unit and cleanup ephemeral files
down.$(SERVICE):
	@cd "$(PROJECT)" && SERVICE="$(SERVICE)" PROJECT="$(PROJECT)" ENTRY="$(ENTRY)" \
	  (uv run -- python tools/uuctl.py down || uv run -- python "$(UUCTL_FALLBACK)" down)

# one-line ps output
ps.$(SERVICE):
	@cd "$(PROJECT)" && SERVICE="$(SERVICE)" PROJECT="$(PROJECT)" ENTRY="$(ENTRY)" \
	  (uv run -- python tools/uuctl.py ps || uv run -- python "$(UUCTL_FALLBACK)" ps)

# logs: show tail of RUNLOG, fallback to journal
logs.$(SERVICE):
	@cd "$(PROJECT)" && SERVICE="$(SERVICE)" PROJECT="$(PROJECT)" ENTRY="$(ENTRY)" TAIL="$(TAIL)" \
	  (uv run -- python tools/uuctl.py logs || uv run -- python "$(UUCTL_FALLBACK)" logs)

# follow logs
follow.$(SERVICE):
	@cd "$(PROJECT)" && SERVICE="$(SERVICE)" PROJECT="$(PROJECT)" ENTRY="$(ENTRY)" \
	  (uv run -- python tools/uuctl.py follow || uv run -- python "$(UUCTL_FALLBACK)" follow)

# restart
restart.$(SERVICE):
	@cd "$(PROJECT)" && SERVICE="$(SERVICE)" PROJECT="$(PROJECT)" ENTRY="$(ENTRY)" RELOAD="$(RELOAD)" KEEP_N="$(KEEP_N)" SECURE="$(SECURE)" \
	  (uv run -- python tools/uuctl.py restart || uv run -- python "$(UUCTL_FALLBACK)" restart)

# foreground doctor mode (no systemd)
doctor.$(SERVICE):
	@cd "$(PROJECT)" && SERVICE="$(SERVICE)" PROJECT="$(PROJECT)" ENTRY="$(ENTRY)" \
	  (uv run -- python tools/uuctl.py doctor || uv run -- python "$(UUCTL_FALLBACK)" doctor)

unit.$(SERVICE):
	@cd "$(PROJECT)" && SERVICE="$(SERVICE)" PROJECT="$(PROJECT)" ENTRY="$(ENTRY)" \
	  (uv run -- python tools/uuctl.py unit || uv run -- python "$(UUCTL_FALLBACK)" unit)

journal.$(SERVICE):
	@cd "$(PROJECT)" && SERVICE="$(SERVICE)" PROJECT="$(PROJECT)" ENTRY="$(ENTRY)" \
	  (uv run -- python tools/uuctl.py journal || uv run -- python "$(UUCTL_FALLBACK)" journal)

# watch: restart-if-running then follow
watch.$(SERVICE):
	@cd "$(PROJECT)" && SERVICE="$(SERVICE)" PROJECT="$(PROJECT)" ENTRY="$(ENTRY)" RELOAD="$(RELOAD)" \
	  (uv run -- python tools/uuctl.py watch || uv run -- python "$(UUCTL_FALLBACK)" watch)

# launch: restart-if-running then show recent logs (alias: run)
launch.$(SERVICE):
	@cd "$(PROJECT)" && SERVICE="$(SERVICE)" PROJECT="$(PROJECT)" ENTRY="$(ENTRY)" RELOAD="$(RELOAD)" \
	  (uv run -- python tools/uuctl.py launch || uv run -- python "$(UUCTL_FALLBACK)" launch)

run.$(SERVICE): launch.$(SERVICE)

# kill: stop all we-$(SERVICE)-* user units
kill.$(SERVICE):
	@cd "$(PROJECT)" && SERVICE="$(SERVICE)" PROJECT="$(PROJECT)" ENTRY="$(ENTRY)" \
	  (uv run -- python tools/uuctl.py kill || uv run -- python "$(UUCTL_FALLBACK)" kill)

# unsuffixed guard
# Unsuffixed proxy targets - proxy to the single service or error with hint
DEFAULT_SERVICE := \$(firstword \$(WE_SERVICES))

up:
	@if [ -n "$(SERVICE)" ]; then $(MAKE) up.$(SERVICE); \
	elif [ $(words $(WE_SERVICES)) -eq 1 ]; then $(MAKE) up.$(DEFAULT_SERVICE); else echo "Multiple services: $(WE_SERVICES). Use SERVICE=<name>"; exit 1; fi

down:
	@if [ -n "$(SERVICE)" ]; then $(MAKE) down.$(SERVICE); \
	elif [ $(words $(WE_SERVICES)) -eq 1 ]; then $(MAKE) down.$(DEFAULT_SERVICE); else echo "Multiple services: $(WE_SERVICES). Use SERVICE=<name>"; exit 1; fi

ps:
	@if [ -n "$(SERVICE)" ]; then $(MAKE) ps.$(SERVICE); \
	elif [ $(words $(WE_SERVICES)) -eq 1 ]; then $(MAKE) ps.$(DEFAULT_SERVICE); else echo "Multiple services: $(WE_SERVICES). Use SERVICE=<name>"; exit 1; fi

logs:
	@if [ -n "$(SERVICE)" ]; then $(MAKE) logs.$(SERVICE); \
	elif [ $(words $(WE_SERVICES)) -eq 1 ]; then $(MAKE) logs.$(DEFAULT_SERVICE); else echo "Multiple services: $(WE_SERVICES). Use SERVICE=<name>"; exit 1; fi

follow:
	@if [ -n "$(SERVICE)" ]; then $(MAKE) follow.$(SERVICE); \
	elif [ $(words $(WE_SERVICES)) -eq 1 ]; then $(MAKE) follow.$(DEFAULT_SERVICE); else echo "Multiple services: $(WE_SERVICES). Use SERVICE=<name>"; exit 1; fi

restart:
	@if [ -n "$(SERVICE)" ]; then $(MAKE) restart.$(SERVICE); \
	elif [ $(words $(WE_SERVICES)) -eq 1 ]; then $(MAKE) restart.$(DEFAULT_SERVICE); else echo "Multiple services: $(WE_SERVICES). Use SERVICE=<name>"; exit 1; fi

doctor:
	@if [ -n "$(SERVICE)" ]; then $(MAKE) doctor.$(SERVICE); \
	elif [ $(words $(WE_SERVICES)) -eq 1 ]; then $(MAKE) doctor.$(DEFAULT_SERVICE); else echo "Multiple services: $(WE_SERVICES). Use SERVICE=<name>"; exit 1; fi

unit:
	@if [ -n "$(SERVICE)" ]; then $(MAKE) unit.$(SERVICE); \
	elif [ $(words $(WE_SERVICES)) -eq 1 ]; then $(MAKE) unit.$(DEFAULT_SERVICE); else echo "Multiple services: $(WE_SERVICES). Use SERVICE=<name>"; exit 1; fi

journal:
	@if [ -n "$(SERVICE)" ]; then $(MAKE) journal.$(SERVICE); \
	elif [ $(words $(WE_SERVICES)) -eq 1 ]; then $(MAKE) journal.$(DEFAULT_SERVICE); else echo "Multiple services: $(WE_SERVICES). Use SERVICE=<name>"; exit 1; fi

watch:
	@if [ -n "$(SERVICE)" ]; then $(MAKE) watch.$(SERVICE); \
	elif [ $(words $(WE_SERVICES)) -eq 1 ]; then $(MAKE) watch.$(DEFAULT_SERVICE); else echo "Multiple services: $(WE_SERVICES). Use SERVICE=<name>"; exit 1; fi

launch:
	@if [ -n "$(SERVICE)" ]; then $(MAKE) launch.$(SERVICE); \
	elif [ $(words $(WE_SERVICES)) -eq 1 ]; then $(MAKE) launch.$(DEFAULT_SERVICE); else echo "Multiple services: $(WE_SERVICES). Use SERVICE=<name>"; exit 1; fi

run:
	@if [ -n "$(SERVICE)" ]; then $(MAKE) run.$(SERVICE); \
	elif [ $(words $(WE_SERVICES)) -eq 1 ]; then $(MAKE) run.$(DEFAULT_SERVICE); else echo "Multiple services: $(WE_SERVICES). Use SERVICE=<name>"; exit 1; fi

kill:
	@if [ -n "$(SERVICE)" ]; then $(MAKE) kill.$(SERVICE); \
	elif [ $(words $(WE_SERVICES)) -eq 1 ]; then $(MAKE) kill.$(DEFAULT_SERVICE); else echo "Multiple services: $(WE_SERVICES). Use SERVICE=<name>"; exit 1; fi

# helper lines expected by validator
check-service:
	@echo "check-service placeholder"

# END: we-managed-block
EOF
  # Write the makefile
  # Substitute placeholders with actual values
  # Use '|' delimiter for sed to avoid issues with paths containing '/'
  sed -e "s|__WE_SERVICE__|$SERVICE|g" \
      -e "s|__WE_PROJECT__|$PROJECT|g" \
      -e "s|__WE_ENTRY__|$ENTRY|g" \
      "$tmp" > "$out"
  rm -f "$tmp"
}

upsert_readme(){
  local out=${1:-README.md}
  local tmp="/tmp/we_readme.$$"
  cat > "$tmp" <<'EOF'
<!-- BEGIN: we-readme -->
# Development runner (we)

This project includes a Make block managed by the `we` tool.

Quick commands:

- make up         # start service (idempotent)
- make watch      # up (or restart if active) + follow
- make launch     # up (or restart if active) + logs (alias: run)
- make follow     # tail logs
- make logs       # show last N lines (TAIL=100)
- make down       # stop tracked unit
- make kill       # stop all we-<service>-* units for this user

RELOAD=1 enables live reload via watchexec; set RELOAD=0 to disable. Set SECURE=1 to enable systemd hardening flags.

Make output is quiet by default (only service output). Use `make VERBOSE=1 <target>` for full make chatter.

<!-- END: we-readme -->
EOF
  if [ -f "$out" ]; then
    in_block=0
    : > "$out.trimmed"
    while IFS= read -r line; do
      case "$line" in
        *"BEGIN: we-readme"*) in_block=1; continue;;
        *"END: we-readme"*) in_block=0; continue;;
      esac
      if [ "$in_block" -eq 0 ]; then echo "$line" >> "$out.trimmed"; fi
    done < "$out" || true
    mv "$out.trimmed" "$out"
  fi
  cat "$tmp" >> "$out"
  rm -f "$tmp"
}


ensure_gitignore(){
  if [ ! -f .gitignore ]; then
    echo ".we/" > .gitignore
  else
    if ! grep -q "^\.we/" .gitignore; then
      echo ".we/" >> .gitignore
    fi
  fi
}

finalize_files(){
  # nothing for now; placeholder if we staged temp files
  return 0
}
